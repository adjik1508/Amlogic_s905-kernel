// SPDX-License-Identifier: GPL-2.0+
/*
 * Copyright (C) 2018 Maxime Jourdan <maxi.jourdan@wanadoo.fr>
 */

#include <linux/init.h>
#include <linux/ioctl.h>
#include <linux/list.h>
#include <linux/module.h>
#include <linux/of_device.h>
#include <linux/platform_device.h>
#include <media/videobuf2-dma-contig.h>
#include <media/v4l2-mem2mem.h>

#include "esparser.h"

/* PARSER REGS (CBUS) */
#define PARSER_CONTROL 0x00
	#define ES_PACK_SIZE_BIT	8
	#define ES_WRITE		BIT(5)
	#define ES_SEARCH		BIT(1)
	#define ES_PARSER_START		BIT(0)
#define PARSER_FETCH_ADDR 0x4
#define PARSER_FETCH_CMD  0x8
#define PARSER_CONFIG 0x14
	#define PS_CFG_MAX_FETCH_CYCLE_BIT  0
	#define PS_CFG_STARTCODE_WID_24_BIT 10
	#define PS_CFG_MAX_ES_WR_CYCLE_BIT  12
	#define PS_CFG_PFIFO_EMPTY_CNT_BIT  16
#define PFIFO_WR_PTR 0x18
#define PFIFO_RD_PTR 0x1c
#define PARSER_SEARCH_PATTERN 0x24
	#define ES_START_CODE_PATTERN 0x00000100
#define PARSER_SEARCH_MASK 0x28
	#define ES_START_CODE_MASK	0xffffff00
	#define FETCH_ENDIAN_BIT	  27
#define PARSER_INT_ENABLE 0x2c
	#define PARSER_INT_HOST_EN_BIT 8
#define PARSER_INT_STATUS 0x30
	#define PARSER_INTSTAT_SC_FOUND 1
#define PARSER_ES_CONTROL 0x5c
#define PARSER_VIDEO_START_PTR 0x80
#define PARSER_VIDEO_END_PTR 0x84
#define PARSER_VIDEO_HOLE 0x90

/* STBUF regs */
#define VLD_MEM_VIFIFO_BUF_CNTL 0x3120
	#define MEM_BUFCTRL_MANUAL	BIT(1)

#define SEARCH_PATTERN_LEN   512

static DECLARE_WAIT_QUEUE_HEAD(wq);
static int search_done;

/* Buffer to send to the ESPARSER to signal End Of Stream.
 * Credits to Endless Mobile.
 */
#define EOS_TAIL_BUF_SIZE 1024
static const u8 eos_tail_data[] = {
	0x00, 0x00, 0x00, 0x01, 0x06, 0x05, 0xff, 0xe4, 0xdc, 0x45, 0xe9, 0xbd, 0xe6, 0xd9, 0x48, 0xb7,
	0x96, 0x2c, 0xd8, 0x20, 0xd9, 0x23, 0xee, 0xef, 0x78, 0x32, 0x36, 0x34, 0x20, 0x2d, 0x20, 0x63,
	0x6f, 0x72, 0x65, 0x20, 0x36, 0x37, 0x20, 0x72, 0x31, 0x31, 0x33, 0x30, 0x20, 0x38, 0x34, 0x37,
	0x35, 0x39, 0x37, 0x37, 0x20, 0x2d, 0x20, 0x48, 0x2e, 0x32, 0x36, 0x34, 0x2f, 0x4d, 0x50, 0x45,
	0x47, 0x2d, 0x34, 0x20, 0x41, 0x56, 0x43, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x20, 0x2d, 0x20,
	0x43, 0x6f, 0x70, 0x79, 0x6c, 0x65, 0x66, 0x74, 0x20, 0x32, 0x30, 0x30, 0x33, 0x2d, 0x32, 0x30,
	0x30, 0x39, 0x20, 0x2d, 0x20, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e,
	0x76, 0x69, 0x64, 0x65, 0x6f, 0x6c, 0x61, 0x6e, 0x2e, 0x6f, 0x72, 0x67, 0x2f, 0x78, 0x32, 0x36,
	0x34, 0x2e, 0x68, 0x74, 0x6d, 0x6c, 0x20, 0x2d, 0x20, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x3a, 0x20, 0x63, 0x61, 0x62, 0x61, 0x63, 0x3d, 0x31, 0x20, 0x72, 0x65, 0x66, 0x3d, 0x31, 0x20,
	0x64, 0x65, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x3d, 0x31, 0x3a, 0x30, 0x3a, 0x30, 0x20, 0x61, 0x6e,
	0x61, 0x6c, 0x79, 0x73, 0x65, 0x3d, 0x30, 0x78, 0x31, 0x3a, 0x30, 0x78, 0x31, 0x31, 0x31, 0x20,
	0x6d, 0x65, 0x3d, 0x68, 0x65, 0x78, 0x20, 0x73, 0x75, 0x62, 0x6d, 0x65, 0x3d, 0x36, 0x20, 0x70,
	0x73, 0x79, 0x5f, 0x72, 0x64, 0x3d, 0x31, 0x2e, 0x30, 0x3a, 0x30, 0x2e, 0x30, 0x20, 0x6d, 0x69,
	0x78, 0x65, 0x64, 0x5f, 0x72, 0x65, 0x66, 0x3d, 0x30, 0x20, 0x6d, 0x65, 0x5f, 0x72, 0x61, 0x6e,
	0x67, 0x65, 0x3d, 0x31, 0x36, 0x20, 0x63, 0x68, 0x72, 0x6f, 0x6d, 0x61, 0x5f, 0x6d, 0x65, 0x3d,
	0x31, 0x20, 0x74, 0x72, 0x65, 0x6c, 0x6c, 0x69, 0x73, 0x3d, 0x30, 0x20, 0x38, 0x78, 0x38, 0x64,
	0x63, 0x74, 0x3d, 0x30, 0x20, 0x63, 0x71, 0x6d, 0x3d, 0x30, 0x20, 0x64, 0x65, 0x61, 0x64, 0x7a,
	0x6f, 0x6e, 0x65, 0x3d, 0x32, 0x31, 0x2c, 0x31, 0x31, 0x20, 0x63, 0x68, 0x72, 0x6f, 0x6d, 0x61,
	0x5f, 0x71, 0x70, 0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x3d, 0x2d, 0x32, 0x20, 0x74, 0x68,
	0x72, 0x65, 0x61, 0x64, 0x73, 0x3d, 0x31, 0x20, 0x6e, 0x72, 0x3d, 0x30, 0x20, 0x64, 0x65, 0x63,
	0x69, 0x6d, 0x61, 0x74, 0x65, 0x3d, 0x31, 0x20, 0x6d, 0x62, 0x61, 0x66, 0x66, 0x3d, 0x30, 0x20,
	0x62, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x73, 0x3d, 0x30, 0x20, 0x6b, 0x65, 0x79, 0x69, 0x6e, 0x74,
	0x3d, 0x32, 0x35, 0x30, 0x20, 0x6b, 0x65, 0x79, 0x69, 0x6e, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x3d,
	0x32, 0x35, 0x20, 0x73, 0x63, 0x65, 0x6e, 0x65, 0x63, 0x75, 0x74, 0x3d, 0x34, 0x30, 0x20, 0x72,
	0x63, 0x3d, 0x61, 0x62, 0x72, 0x20, 0x62, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x3d, 0x31, 0x30,
	0x20, 0x72, 0x61, 0x74, 0x65, 0x74, 0x6f, 0x6c, 0x3d, 0x31, 0x2e, 0x30, 0x20, 0x71, 0x63, 0x6f,
	0x6d, 0x70, 0x3d, 0x30, 0x2e, 0x36, 0x30, 0x20, 0x71, 0x70, 0x6d, 0x69, 0x6e, 0x3d, 0x31, 0x30,
	0x20, 0x71, 0x70, 0x6d, 0x61, 0x78, 0x3d, 0x35, 0x31, 0x20, 0x71, 0x70, 0x73, 0x74, 0x65, 0x70,
	0x3d, 0x34, 0x20, 0x69, 0x70, 0x5f, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x3d, 0x31, 0x2e, 0x34, 0x30,
	0x20, 0x61, 0x71, 0x3d, 0x31, 0x3a, 0x31, 0x2e, 0x30, 0x30, 0x00, 0x80, 0x00, 0x00, 0x00, 0x01,
	0x67, 0x4d, 0x40, 0x0a, 0x9a, 0x74, 0xf4, 0x20, 0x00, 0x00, 0x03, 0x00, 0x20, 0x00, 0x00, 0x06,
	0x51, 0xe2, 0x44, 0xd4, 0x00, 0x00, 0x00, 0x01, 0x68, 0xee, 0x32, 0xc8, 0x00, 0x00, 0x00, 0x01,
	0x65, 0x88, 0x80, 0x20, 0x00, 0x08, 0x7f, 0xea, 0x6a, 0xe2, 0x99, 0xb6, 0x57, 0xae, 0x49, 0x30,
	0xf5, 0xfe, 0x5e, 0x46, 0x0b, 0x72, 0x44, 0xc4, 0xe1, 0xfc, 0x62, 0xda, 0xf1, 0xfb, 0xa2, 0xdb,
	0xd6, 0xbe, 0x5c, 0xd7, 0x24, 0xa3, 0xf5, 0xb9, 0x2f, 0x57, 0x16, 0x49, 0x75, 0x47, 0x77, 0x09,
	0x5c, 0xa1, 0xb4, 0xc3, 0x4f, 0x60, 0x2b, 0xb0, 0x0c, 0xc8, 0xd6, 0x66, 0xba, 0x9b, 0x82, 0x29,
	0x33, 0x92, 0x26, 0x99, 0x31, 0x1c, 0x7f, 0x9b
};

static irqreturn_t esparser_isr(int irq, void *dev)
{
	int int_status;
	struct vdec_core *core = dev;

	int_status = readl_relaxed(core->esparser_base + PARSER_INT_STATUS);
	writel_relaxed(int_status, core->esparser_base + PARSER_INT_STATUS);

	//printk("esparser_isr! status = %08X\n", int_status);

	if (int_status & PARSER_INTSTAT_SC_FOUND) {
		writel_relaxed(0, core->esparser_base + PFIFO_RD_PTR);
		writel_relaxed(0, core->esparser_base + PFIFO_WR_PTR);
		search_done = 1;
		wake_up_interruptible(&wq);
	}

	return IRQ_HANDLED;
}

/* Add a start code at the end of the buffer
 * to trigger the esparser interrupt
 */
static void esparser_append_start_code(struct vb2_buffer *vb)
{
	u8 *vaddr = vb2_plane_vaddr(vb, 0) + vb2_get_plane_payload(vb, 0);

	vaddr[0] = 0x00;
	vaddr[1] = 0x00;
	vaddr[2] = 0x01;
	vaddr[3] = 0xff;
}

static int
esparser_write_data(struct vdec_core *core, dma_addr_t addr, u32 size)
{
	writel_relaxed(0, core->esparser_base + PFIFO_RD_PTR);
	writel_relaxed(0, core->esparser_base + PFIFO_WR_PTR);
	writel_relaxed(ES_WRITE | ES_PARSER_START | ES_SEARCH | (size << ES_PACK_SIZE_BIT), core->esparser_base + PARSER_CONTROL);

	writel_relaxed(addr, core->esparser_base + PARSER_FETCH_ADDR);
	writel_relaxed((7 << FETCH_ENDIAN_BIT) | (size + 512), core->esparser_base + PARSER_FETCH_CMD);
	search_done = 0;

	return wait_event_interruptible_timeout(wq, search_done != 0, HZ/5);
}

static u32 esparser_vififo_get_free_space(struct vdec_session *sess)
{
	u32 vififo_usage;
	struct vdec_ops *vdec_ops = sess->fmt_out->vdec_ops;
	struct vdec_core *core = sess->core;

	vififo_usage  = vdec_ops->vififo_level(sess);
	vififo_usage += readl_relaxed(core->esparser_base + PARSER_VIDEO_HOLE);
	vififo_usage += (6 * SZ_1K);

	if (vififo_usage > sess->vififo_size) {
		dev_warn(sess->core->dev_dec,
			"VIFIFO usage (%u) > VIFIFO size (%u)\n",
			vififo_usage, sess->vififo_size);
		return 0;
	}

	return sess->vififo_size - vififo_usage;
}

int esparser_queue_eos(struct vdec_session *sess)
{
	struct device *dev = sess->core->dev;
	struct vdec_core *core = sess->core;
	void *eos_vaddr;
	dma_addr_t eos_paddr;
	int ret;

	eos_vaddr = dma_alloc_coherent(dev, sizeof(eos_tail_data) + 512, &eos_paddr, GFP_KERNEL);
	if (!eos_vaddr)
		return -ENOMEM;

	sess->should_stop = 1;

	memcpy(eos_vaddr, eos_tail_data, sizeof(eos_tail_data));
	ret = esparser_write_data(core, eos_paddr, sizeof(eos_tail_data));
	dma_free_coherent(dev, sizeof(eos_tail_data) + 512,
			  eos_vaddr, eos_paddr);

	return ret;
}

static int esparser_queue(struct vdec_session *sess, struct vb2_v4l2_buffer *vbuf)
{
	int ret;
	struct vb2_buffer *vb = &vbuf->vb2_buf;
	struct vdec_core *core = sess->core;
	u32 payload_size = vb2_get_plane_payload(vb, 0);
	dma_addr_t phy = vb2_dma_contig_plane_dma_addr(vb, 0);

	if (!payload_size) {
		esparser_queue_eos(sess);
		return 0;
	}

	if (esparser_vififo_get_free_space(sess) < payload_size ||
	    atomic_read(&sess->esparser_queued_bufs) >= 17)
		return -EAGAIN;

	v4l2_m2m_src_buf_remove_by_buf(sess->m2m_ctx, vbuf);
	vdec_add_buf_reorder(sess, vb->timestamp);

	esparser_append_start_code(vb);
	ret = esparser_write_data(core, phy, payload_size);

	if (ret > 0) {
		vbuf->flags = 0;
		vbuf->field = V4L2_FIELD_NONE;
		v4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);
	} else if (ret <= 0) {
		printk("ESPARSER input parsing error\n");
		vdec_remove_buf(sess, vb->timestamp);
		v4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);
		writel_relaxed(0, core->esparser_base + PARSER_FETCH_CMD);
	}

	if (vbuf->flags & V4L2_BUF_FLAG_LAST)
		esparser_queue_eos(sess);

	return 0;
}

void esparser_queue_all_src(struct work_struct *work)
{
	struct v4l2_m2m_buffer *buf, *n;
	struct vdec_session *sess =
		container_of(work, struct vdec_session, esparser_queue_work);

	v4l2_m2m_for_each_src_buf_safe(sess->m2m_ctx, buf, n) {
		if (esparser_queue(sess, &buf->vb) < 0)
			break;

		atomic_inc(&sess->esparser_queued_bufs);
	}
}

int esparser_power_up(struct vdec_session *sess)
{
	struct vdec_core *core = sess->core;
	struct vdec_ops *vdec_ops = sess->fmt_out->vdec_ops;

	writel_relaxed((10 << PS_CFG_PFIFO_EMPTY_CNT_BIT) |
				(1  << PS_CFG_MAX_ES_WR_CYCLE_BIT) |
				(16 << PS_CFG_MAX_FETCH_CYCLE_BIT),
				core->esparser_base + PARSER_CONFIG);

	writel_relaxed(0, core->esparser_base + PFIFO_RD_PTR);
	writel_relaxed(0, core->esparser_base + PFIFO_WR_PTR);

	writel_relaxed(ES_START_CODE_PATTERN, core->esparser_base + PARSER_SEARCH_PATTERN);
	writel_relaxed(ES_START_CODE_MASK,    core->esparser_base + PARSER_SEARCH_MASK);

	writel_relaxed((10 << PS_CFG_PFIFO_EMPTY_CNT_BIT) |
				   (1  << PS_CFG_MAX_ES_WR_CYCLE_BIT) |
				   (16 << PS_CFG_MAX_FETCH_CYCLE_BIT) |
				   (2  << PS_CFG_STARTCODE_WID_24_BIT),
				   core->esparser_base + PARSER_CONFIG);

	writel_relaxed((ES_SEARCH | ES_PARSER_START), core->esparser_base + PARSER_CONTROL);

	writel_relaxed(sess->vififo_paddr, core->esparser_base + PARSER_VIDEO_START_PTR);
	writel_relaxed(sess->vififo_paddr + sess->vififo_size - 8, core->esparser_base + PARSER_VIDEO_END_PTR);
	writel_relaxed(readl_relaxed(core->esparser_base + PARSER_ES_CONTROL) & ~1, core->esparser_base + PARSER_ES_CONTROL);
	
	if (vdec_ops->conf_esparser)
		vdec_ops->conf_esparser(sess);

	writel_relaxed(0xffff, core->esparser_base + PARSER_INT_STATUS);
	writel_relaxed(1 << PARSER_INT_HOST_EN_BIT, core->esparser_base + PARSER_INT_ENABLE);

	return 0;
}

int esparser_init(struct platform_device *pdev, struct vdec_core *core)
{
	int ret;
	int irq;

	/* TODO: name the IRQs */
	irq = platform_get_irq(pdev, 1);
	if (irq < 0) {
		printk("Failed getting IRQ\n");
		return irq;
	}

	printk("Requesting IRQ %d\n", irq);

	ret = devm_request_irq(&pdev->dev, irq, esparser_isr,
					IRQF_SHARED,
					"esparserirq", core);
	if (ret) {
		printk("Failed requesting IRQ\n");
		return ret;
	}

	return 0;
}